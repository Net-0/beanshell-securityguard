#!/bin/sh
#
# Run the BeanShell interpreter on a file with command line arguments.  If the
# user has a classpath and the case insensitive string [^A-Za-z]bsh or
# beanshell appears in any part of the path, the interpreter is executed with
# the user's path.  Otherwise, the default bsh path specified in DEFAULTBSH is
# added to end of the user's path.
#

# The (hard coded) location of a default bsh jar.
# e.g. Win
#DEFAULTBSH=`cygpath --windows $HOME/bin/bsh-1.3a1.jar`
# e.g. Unix
DEFAULTBSH=/home/pat/bin/bsh-1.3a1.jar

name=`basename $0`
if [ $name = "bshd" ]; then
	debug="-Ddebug=true"
fi

# Determine if we're running under Unix or Cygwin/windows
if uname | grep -i 'cygwin' 2>&1 > /dev/null
then
	# (Using cygpath has issues with drive letters, etc.)
	_PATHSEP=';'
	_CYGWIN=true;
else
	_PATHSEP=':'
fi

if [ ! -f $DEFAULTBSH ]; then
	echo "BeanShell not found at path: $DEFAULTBSH"
	exit;
fi

# Try to avoid adding the bsh jar to the classpath unecessarily.
# For most purposes this wouldn't matter... but for testing bsh we'd like to
# avoid extra bsh junk.
#
if echo $CLASSPATH | egrep -i '[^A-Za-z]bsh|beanshell' 2>&1 > /dev/null
then
	# Have bsh
	java $debug bsh.Interpreter $* 
else
	# Don't have bsh
	# Cygwin doesn't like an extra leading path separator, avoid it
	if [ "$CLASSPATH" ]; then
		path="${CLASSPATH}${_PATHSEP}${DEFAULTBSH}"
	else
		path=${DEFAULTBSH}
	fi

	java $debug -classpath $path bsh.Interpreter $* 
fi

