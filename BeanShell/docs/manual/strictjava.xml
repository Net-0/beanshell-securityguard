<section>
<name filename="strictjava">Strict Java Mode</name>

<em>Note: Strict Java Mode is new and currently breaks some BeanShell tools
and APIs when activated.  The GUI desktop will not work with strict Java
mode enabled.  Please see notes at the end of this page</em>
<p/>

If you are a Java teacher or a student learning the Java language and
you would like to avoid any potential confusion relating to BeanShell's
use of loose variable types, you can turn on Strict Java Mode.  Strict
Java Mode is enabled with the the setStrictJava() command.

When strict Java mode is enabled BeanShell will:
<p/>

<ol>
<li>Require typed variable declarations, method arguments and return types.</li>
<li>Modify the scoping of variables to look for the variable declaration 
in the parent namespace where appropriate, as in a java method inside a 
java class.</li>
</ol>

For example:
<example>
setStrictJava(true);

int a = 5;

foo=42; // Error! Undeclared variable 'foo'.

bar() { .. } // Error! No declared return type.
</example>

Turning on strict Java mode can clear up the one potential ambiguity with 
standard Java: where auto-allocation of local variables makes local variable 
assignment look like a reference to a variable in an enclosing scope.

<example>
// A common BeanShell "gotcha"!

incrementX() {
    x = x + 1; // Really a local assignment
}

x = 5;
incrementX();
print( x ); // 5!
</example>

In the example above you may have been expecting the reference to x to 
increment the variable in the enclosing context, as if it were a method in
a Java class.  However the penalty we pay for allowing the use of undeclared
variables in BeanShell is that we always assume assignment is in the local
scope, unless qualified.  In practice, this situation doesn't come up as
often as you'd think.  And we could easily fix it with the BeanShell 'super'
reference like so:

<example>
incrementX() {
    super.x = x + 1; // refer to parent scope explicitly
}
</example>

However this is unsatisfying if you are more interested in standard Java
syntax than in accomplishing silly scripting tasks.  Turning on Strict
Java mode solves the problem by forcing you to declare your types and 
disambiguating the reference.

<example>
// Strict Java Mode

setStrictJava(true);

void incrementX() {
    x = x + 1;
}

int x = 5;  // Must declare variables before use
incrementX();
System.out.println( x ); // 6!
</example>

<note>
Strict Java Mode is relatively new.
In the above example we switched to using System.out.println() instead
of print() because the print() command and most other BeanShell commands
have not yet been re-written to accommodate strict Java mode.
<p/>

For embedded use the Interpreter set() method will also fail in strict Java 
mode because performing a set() is equivalent to setting an utyped variable.
As a temporary workaround you may use eval() to "declare" your variable first,
then set() to assign in the value.
</note>

</section>
