<section>
<name>BeanShell Syntax</name>

BeanShell is primarily a Java interpreter, so you probably already know 
most of what you need to start using and scripting BeanShell.  This section
will describe specifically what portion of the Java langauge bsh interprets
and how bsh extends it - loosens it up - to be more scripting language like.
<p/>

<h2> Standard Java Syntax </h2>

At the prompt you can type normal Java statements and expressions and 
display the results.  
Statements and expressions are the kinds of things you normally find 
inside of a Java method - variable assignments, method calls, math 
expressions, for-loops, etc.
<p/>

Here are some examples:

<example>
// Use a hashtable
Hashtable h = new Hashtable();
Date d = new Date();
h.put("today", d);

// Print the current clock value
print( System.currentTimeMillis() );

// Loop
for (int i=0; i&lt;5; i++)
    print(i);

// Pop up a frame with a button in it
JButton button = new JButton( "My Button" );
JFrame frame = new JFrame( "My Frame" );
frame.getContentPane().add( button, "Center" );
frame.pack();
frame.setVisible(true);
</example>

<h2> Loose Java Syntax </h2>

In the examples above, all of our variables have declared types - e.g. 
'JButton button'.  Beanshell will enforce these types, as you will see if you 
later try to 
assign something other than a JButton to the variable 'button' (you will get
an error message).
However bsh also supports "loose" or dynamically typed variables - that is, 
you can refer to 
variables without declaring them first and without specifying any type.
In this case BeanShell will do type checking where appropriate at "runtime".  
So, for example, we could have left off the types in the above example and 
simply said something like:
<example>
foo = new JButton("Another Button");
</example>

We are then free to reassign 'foo' to another type of Java object later.
Untyped bsh variables can also freely hold Java primitive values like <b>int</b>
and <b>boolean</b>.  Don't worry, BeanShell always knows the real types and 
only lets you use the values where appropriate.  For primitive types this 
includes doing the
correct numeric promotion that the real Java language would do when you use
them in an expression.
<p/>
<p/>

<h2>
Convenience Syntax
</h2>

In bsh you may access JavaBean properties as if they were fields:

<pre>
    button = new java.awt.Button();
    button.label = "my button";  // Equivalent to: b.setLabel("my button");
</pre>

Of course if there is a field of the same name (e.g. label in the above
example) then it would take precedence.
<p/>

If you wish to avoid ambiguity Bsh provides an additional, uniform syntax for 
accessing Java Bean properties and Map type entries.  
You may use the "{}" curly brace construct with a 
String identifier as a qualifier on any variable of the appropriate type:

<example>
b = new java.awt.Button();
b{"label"} = "my button";  // Equivalent to: b.setLabel("my button");

h = new Hashtable();
h{"foo"} = "bar";          // Equivalent to: h.put("foo", "bar");
</example>

<h2>
Importing classes and packages
</h2>

In BeanShell as in Java, you can either refer to classes by their fully
qualified names, or you can <strong>import</strong> one or more classes 
from a Java package.
<p/>

<example>
    import mypackage.MyClass;
or
    import mypackage.*;
</example>
<p/>

In BeanShell import statements may appear anywhere - not just at the top of
a script and, in the event of a conflict, later imports take precedence over 
earlier ones.
<p/>

A somewhat experimental feature is the "super import".  With it you may 
automatically import the entire classpath, like so:

<example>
import *;
</example>

The first time you do this BeanShell will map out your entire classpath.
So this is primarily intended for interactive use.  Note that importing every
class in your classpath can result in a lot of ambiguities.  Currently
BeanShell will report an error when resolving an an ambiguous import from
mapping the entire classpath.  You may disambiguate it by importing the 
class you intend.
<p/>

See Class Path Management for details.
<p/>

By default, most Java core and extension packages are imported for 
you.  They are:

<em>List needs update...</em>
<ul>
<li>java.lang</li>
<li>java.awt</li>
<li>java.awt.event</li>
<li>javax.swing</li>
<li>javax.swing.event</li>
<li>java.util</li>
<li>java.io</li>
<li>java.net</li>
</ul>
<p/>

</section>
