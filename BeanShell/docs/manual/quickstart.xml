<section>
<name>Quick Start</name>

Welcome to BeanShell.
This is a crash course to get you going.  We'll leave out some 
important options and details.  Please see the rest of the user's guide 
(which is not very long in its entirety) for more details.
<p/>

<h4>
Download and Run BeanShell
</h4>

Download the latest jar file
and start up BeanShell either in the graphical desktop mode or on 
the command line.
<p/>

If you just want to start playing around you may be able to to launch the 
BeanShell desktop by simply double clicking on the BeanShell JAR file.  More 
generally however you'll want to add the jar to your classpath so that you 
can work with your own classes and applications easily.
<p/>

To do this you can either drop the BeanShell JAR file into your Java 
<b>JRE/lib/ext/</b> folder <em>(Java 1.2 or later)</em> or add it to your 
classpath.

<example>
Place bsh.jar in your $JAVA_HOME/jre/lib/ext folder or add it to your
classpath like this:

<em>unix:</em>     export CLASSPATH=$CLASSPATH:bsh-xx.jar
<em>windows:</em>  set classpath %classpath%;bsh-xx.jar

    java bsh.Console       // run the graphical desktop
or
	java bsh.Interpreter   // run as text-only on the command line
or
	java bsh.Interpreter filename [ args ] // run script from file
</example>
<p/>


Tip: From within BeanShell scripts or the command line you can to BeanShell's
classpath using the addClassPath() command.
<p/>

The above examples show how to run bsh interactively for experimentation. 
It's also possible to run bsh in a server mode, an applet mode, and to embed 
bsh for non-interactive use in your applications.  You can even make 
executable bsh scripts under Unix using the standard "#!" syntax.
<p/>

<h4>
The BeanShell Desktop and Console Windows
</h4>

Upon starting BeanShell one console window will open.  By right clicking on 
the <a href="desktop.html">desktop</a> background can also open additional 
console windows or other tools
such as the BeanShell class browser.  
<p/>

Each console window effectively runs a separate bsh interpreter.
Within the graphical console you have basic command history, line editing,
and cut and paste.  From any console window you can open a simple editor 
window for that console.  In it you can write scripts and hit the 'eval' 
button to evaluate them in the attached workspace. 
<p/>


<h4>
Java Statements and Expressions
</h4>

At the prompt you can type standard Java statements and expressions.  
Statements and expressions are all of the normal things that you'd say
inside a Java method: e.g. variable declarations and assignments, 
method calls, loops, conditionals, etc.  
<p/>

You can use these exactly as they would appear in Java,
however in BeanShell you have the option of working with "loosely typed"
variables.  That is, you can simply be lazy and not declare the types of
variables that you use (both primitives and objects).  BeanShell will still
give you an error if you attempt to misuse the actual type of the variable.
<p/>

Here are some examples:
<example>
	foo = "Foo";	
	four = (2 + 2)*2/2;
	print( foo + " = " + four );   // print() is a bsh command
	
	// Do a loop
    for (i=0; i&lt;5; i++)
        print(i);   

    // Pop up a frame with a button in it
    b = new JButton("My Button");
    f = new JFrame("My Frame");
    f.getContentPane().add(b, "Center");
    f.pack();
    f.show();
</example>
<p/>

<h4>
Useful BeanShell Commands
</h4>

In the previous example we used a convenient "built-in" BeanShell command 
called print(), to display values.  print() does pretty
much the same thing as System.out.println() except that it insures that the
ouput always goes to the command line.  print() also displays some types
of objects (such as arrays) more verbosely than Java would.  

Another very useful command is show(), which toggles on and off automatic 
print()ing of the result of every line you type.
<p/>

Here are a few other examples of BeanShell commands:

<ul>
<li> source(), run()  - read a bsh script into this interpreter, or run it
in a new interpreter</li>
<li> frame()  - display the AWT/JFC component in a Frame</li>
<li> load(),  save() - load or save serializable objects</li>
<li> cd(), cat(), dir(), pwd(), etc.  - Unix-like shell commands</li>
<li> exec() - run a native application </li>
</ul>

<p/>
See the complete list of BeanShell commands for more information.
<p/>

BeanShell commands are simply methods which are implemented by bsh scripts
supplied in the bsh jar file.  You can, of course, define your own methods
in bsh and also add your own scripts to the classpath to extend the basic 
command set.
<p/>


<h4>
Scripted Methods
</h4>

You can declare and use methods in bsh just as you would in a Java class.

<example>
    int addTwoNumbers( int a, int b ) {
        return a + b;
    }

    sum = addTwoNumbers( 5, 7 );  // 12
</example>


Bsh methods may also have dynamic (loose) argument and return types.  

<example>
    add( a, b ) {
        return a + b;
    }

    foo = add(1, 2);  			// 3
    foo = add("Oh", " baby");	// "Oh baby"
</example>

<h4>
Scripted Objects
</h4>

In BeanShell, as in JavaScript and Perl, method "closures" allow you to create
scripted objects.  You can turn the results of a method call into an object
reference by having the method return the special value <strong>this</strong>.
You can then use that reference to refer to any variables set in the method 
call.  To make useful objects you need instance methods of course so in 
BeanShell methods may also contain methods at any level.

<example>
	foo() {
		print("foo");
		x=5;

		bar() {
			print("bar");
		}

		return this;
	}

	myfoo = foo();    // prints "foo"
	print( myfoo.x ); // prints "5"
	myfoo.bar();      // prints "bar"
</example>

If this seems strange to you please see the user's manual for more details.
<p/>

You may also cast your scripted objects (e.g. myFoo above) to any Java 
interface type and supply the necessary methods in the script.
<p/>

<em>Note: implementing interface types requires BeanShell be running under a 
Java 1.3 environment or higher</em>

<h5>Inner Class Style</h5>
<p/>

You may also use the Java anonymous inner class style syntax to implement an
interface type with a script.

<example>
	ActionListener scriptedListener = new ActionListener() {
		actionPerformed( event ) { ... }
	}
</example>

Normally, if you leave out methods required by the interface the calling code
will throw an exception.  However if you wish to override this behavior 
you can implement the special method invoke(name, args) in your scripted 
object to handle undefined method invocations:

<example>
		ml = new MouseListener() {
			mousePressed( event ) { ... }
			// handle the rest
			invoke( name, args ) { print("Method: "+name+" invoked!");
		}
</example>

</section>
