<section>
<name>Visibility and Scope Modifiers</name>

Now that we've seen how methods can be nested and treated as objects, we
can revisit the topic of variable scope and scope modifiers.
BeanShell's first rule is to maintain Java compatability.  Where 
new features are added that go beyond standard Java syntax however, we 
sometimes have to add new rules.  The ability to use loose, undeclared 
variables as they are implemented in BeanShell can make for some situations 
that look ambiguous with respect to Java.
<p/>

As we discussed in the "Syntax" section early on, variables references in 
BeanShell default to the local scope, unless otherwise qualified.  
This is a little different from some other scripting
languages, but we feel is more consistent with Java, with object oriented 
design in general, and a more natural extension of Java syntax into the 
scripting domain.  Now let's look at what this means.
<p/>

In the "Syntax" section we described the use of 'super' to refer to a 
method's parent scope (the scope in which the method is defined).  
And in this section we talked 
about 'super's brother 'this', which refers to the current method's scope,
allowing us to think of a method scope as an object.  Now we can see how 
these concepts are related.  Any method scope can be thought of or used as
an object context. A scripted object can be thought of as encapsulated in a 
parent scope that determines its "environment" - inherited variables and 
methods.  

The references 'this', 'super', and 'global' are really the same
kind of reference - references to BeanShell method contexts, which can 
be thought of as scripted objects.  From here on We'll refer to 'this', 
'super', and any other reference to a scripted object context in general as a 
<em>'this' type reference</em>.
<p/>

<note>
If you print a 'this' type reference you'll see what it refers to:

<pre>
    BeanShell 1.3 - by Pat Niemeyer (pat@pat.net)
    bsh % print( this );
    'this' reference (XThis) to Bsh object: global
    bsh % foo() { print(this); print(super); }
    bsh % foo();
    'this' reference (XThis) to Bsh object: foo
    'this' reference (XThis) to Bsh object: global
</pre>
</note>
<p/>

The above example shows that the foo() method's 'this' reference is local
(named 'foo') and that it's parent is the global scope; the same scope in
which foo is defined.

<h2>'global' and Global Scope</h2>

A third scope modifier, 'global', allows you to always refer to the top-most
scope.  In the previous note you can see that the top level script context
is called "global" and that it appears again as the 'super' of our foo() 
method.  The global context is always the top scope of the script.  Referring
to 'super' from the top scope simply returns the same 'global' again.  

It is legal to say things like the following:

<example>
  super.super.super...foo = 42;  // Chain super. to reach the top
</example>

However if we are really trying to reach the top context it would probably 
better to use 'global' in this situation:

<example>
  global.foo = 42; 
</example>

More generally, in the spirit of object oriented programming we could simply
refer to some other object, defined in a parent context, without specifying
where it is:

<example>
// Create a global object to hold some state
dataholder = object();

foo() {
    ...
    bar() {
        dataholder.value = 42;
    }

    bar();
    print( dataholder.value );
}
    
</example>

In the above example we used a global object to hold some state, rather than
putting the 'value' variable directly in the global scope. 

<tip>
In the above example we used the BeanShell object() command to create an
"empty" BeanShell scripted object context in which to hold some data.  (The
object() command is just a standard empty method named object() that 
returns 'this'.)
</tip>

<h2>'this.caller' and the Caller Context</h2>

<em>This topic is primarily of interest to BeanShell command developers</em>
<p/>

We mentioned earlier the difference between the 'super' or parent context
of a method and the caller's context.  The 'super' of a method is always
the context in which the method was defined.  But the caller may be any context
in which the method is used.  In the following example,
the parent context of foo() and the caller context of foo() are the same:

<example>
foo() { ... }
foo();
</example>

But this is not always the case, as for bar() in the following example:

<example>
foo() { 
    bar() { ... }
	...
}

// somewhere
fooObject.bar();
</example>

The special "magic" field reference: 'this.caller' makes it possible 
to reach the context of whomever called bar().  The 'this.caller' reference 
always refers to the calling context of the current method context.
<p/>

<img src="caller.gif"/>
<p/>

The diagram above shows the foo() and bar() scopes, along with the caller's
scope access via 'this.caller'.
<p/>

The most common example of where this is useful is in writing
BeanShell commands.  BeanShell commands are simply BeanShell methods
contained in external script files, automatically loaded when their name
is invoked.  (You can write your own commands and add them to the classpath
if you wish.)  BeanShell command methods are always loaded into the global 
scope.  If you refer to 'super' from your BeanShell command you will simply 
get 'global'.  Often it is desirable to write commands that explicitly have 
side effects in the caller's scope.  The ability to do so makes it possible to
write new kinds of commands that have the appearance of being "built-in" 
to the language.  
<p/>

A good example of this is the eval() BeanShell command.  eval() evaluates
a string as if it were typed in the current context.  To do this, it sends
the string to an instance of the BeanShell interpreter.  But when it does
so it tells the interpreter to evaluate the string in a specfic namespace:
the namespace of the caller; using this.caller.

<example>
    eval("a=5");
    print( a ); // 5
</example>

You can follow the call chain further back if you want to by chaining
the '.caller' reference, like so:

<example>
    this.caller.caller...;
</example>

Or, more generally, another magic reference 'this.callstack' returns an
array of bsh.NameSpace objects representing the full call "stack".  This is
an advanced topic for developers that we'll discuss in another location.

</section>

