<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="bshcommands.xsl"?>
<!-- This file was auto-generated by the bshdoc.bsh script -->
<BshDoc>
  <File>
    <Name>addClassPath</Name>
    <Method>
      <Name>addClassPath</Name>
      <Sig>addClassPath ( path ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Add the specified directory or JAR file to the class path.
	e.g.
	<p>
	<pre>
    addClassPath( "/home/pat/java/classes" );
    addClassPath( "/home/pat/java/mystuff.jar" );
    addClassPath( new URL("http://myserver/~pat/somebeans.jar") );
	</pre>
	<p>
	See <a href="classpath.html">Class Path Management</a>
]]></Text>
      <Tags>
      <method>void addClassPath( string | URL )
</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>bg</Name>
    <Method>
      <Name>bg</Name>
      <Sig>Thread bg ( String filename ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Source a command in its own thread in the caller's namespace
	<p>

	This is like run() except that it runs the command in its own thread.  
	Returns the Thread object control.
]]></Text>
      <Tags>
      <method>Thread bg( String filename )
</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>bind</Name>
    <Method>
      <Name>bind</Name>
      <Sig>bind ( bsh .This ths , bsh .NameSpace namespace ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Bind a bsh object into a particular namespace and interpreter

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>browseClass</Name>
    <Method>
      <Name>browseClass</Name>
      <Sig>browseClass ( Object o ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Open the class browser to view the specified class.  
	If the argument is a string it is considered to be a class name.  
	If the argument is an object, the class of the object is used.  
	If the arg is a class, the class is used.
	<p>

	Note: To browse the String class you can't supply a String.
	You'd have to do:  browseClass( String.class );
	<p>
]]></Text>
      <Tags>
      <method>void browseClass( String | Object | Class )
</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>cat</Name>
    <Method>
      <Name>cat</Name>
      <Sig>cat ( String filename ) </Sig>
      <Comment>
      <Text><![CDATA[
	cat comment

]]></Text>
      <Tags>
      </Tags>
      </Comment>
    </Method>
    <Method>
      <Name>cat</Name>
      <Sig>cat ( URL url ) </Sig>
      <Comment>
      <Text><![CDATA[
	cat comment

]]></Text>
      <Tags>
      </Tags>
      </Comment>
    </Method>
    <Method>
      <Name>cat</Name>
      <Sig>cat ( InputStream ins ) </Sig>
    </Method>
    <Method>
      <Name>cat</Name>
      <Sig>cat ( Reader reader ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Print the contents of filename, url, or stream (like Unix cat)

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>cd</Name>
    <Method>
      <Name>cd</Name>
      <Sig>void cd ( String pathname ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Change working directory for dir(), etc. commands (like Unix cd)

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>classBrowser</Name>
    <Method>
      <Name>classBrowser</Name>
      <Sig>classBrowser ( ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Open the class browser.

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>clear</Name>
    <Method>
      <Name>clear</Name>
      <Sig>clear ( ) </Sig>
      <Comment>
      <Text><![CDATA[
	Clear all variables, methods, and imports from this namespace.
	If this namespace is the root, it will be reset to the default 
	imports.
	See NameSpace.clear();
]]></Text>
      <Tags>
      <see>NameSpace.clear();
</see>
      </Tags>
      </Comment>
    </Method>
  </File>
  <File>
    <Name>cp</Name>
    <Method>
      <Name>cp</Name>
      <Sig>cp ( String fromFile , String toFile ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Copy a file (like Unix cp).

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>debug</Name>
    <Method>
      <Name>debug</Name>
      <Sig>debug ( ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Toggle on and off debug mode. 
	Debug output is verbose and generally useful only for developers.

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>desktop</Name>
    <Method>
      <Name>desktop</Name>
      <Sig>desktop ( ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Start the BeanShell GUI desktop.
]]></Text>
      <Tags>
      <method>void desktop()
</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>dirname</Name>
    <Method>
      <Name>dirname</Name>
      <Sig>String dirname ( String pathname ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Return directory portion of path based on the system default file separator.
	Note: you should probably use pathToFile() to localize the path relative
	to BeanShell's working directory and then file.getAbsolutePath() to get
	back to a system localized string.
	<p>
	
	Example: to change to the directory that contains the script we're 
	currently executing:

	<pre>
	// Change to the directory containing this script
	path=pathToFile( getSourceFileInfo() ).getAbsolutePath();
	cd( dirname( path ) );
	</pre>

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>editor</Name>
    <Method>
      <Name>editor</Name>
      <Sig>editor ( ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Open a GUI editor from the command line or in the GUI desktop mode.
	When run from the command line the editor is a simple standalone
	frame.  When run inside the GUI desktop it is a workspace editor.
	See workspaceEditor()

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>error</Name>
    <Method>
      <Name>error</Name>
      <Sig>void error ( item ) </Sig>
      <Comment>
      <Text><![CDATA[
	Print the item as an error.  
	In the GUI console the text will show up in (something like) red, 
	else it will be printed to standard error.

]]></Text>
      <Tags>
      </Tags>
      </Comment>
    </Method>
  </File>
  <File>
    <Name>eval</Name>
    <Method>
      <Name>eval</Name>
      <Sig>Object eval ( String expression ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Evaluate the string in the current interpreter (see source()).
	Returns the result of the evaluation or null.
	<p>

	Evaluate a string as if it were written directly in the current scope, 
	with side effects in the current scope.
	<p>
	e.g.
    <code><pre>
    a=5;
    eval("b=a*2");
    print(b); // 10
    </pre></code>
	<p>

	eval() acts just like invoked text except that any exceptions generated
	by the code are captured in a bsh.EvalError.  This includes ParseException
	for syntactic errors and TargetError for exceptions thrown by the evaluated
	code.
	<p>
	e.g.
    <pre>
    try {
        eval("foo>>><>M>JK$LJLK$");
    } catch ( EvalError e ) {
        // ParseException caught here
    }

    try {
        eval("(Integer)true");  // illegal cast
    } catch ( EvalError e ) {
        // TargetException caught here
        print( e.getTarget() )  // prints ClassCastException
    }
    </pre>
	<p>
	
	If you want eval() to throw target exceptions directly, without wrapping
	them, you can simply redefine own eval like so:

    <pre>
    myEval( String expression ) {
        try {
            return eval( expression );
        } catch ( TargetError e ) {
            throw e.getTarget();
        }
    }
    </pre>

	<p>
	Returns the value of the expression.
	<p>
	Throws bsh.EvalError on error
	<p>
]]></Text>
      <Tags>
      <return>the value of the expression.</return>
      <throws>bsh.EvalError on error
</throws>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>exec</Name>
    <Method>
      <Name>exec</Name>
      <Sig>exec ( String arg ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Start an external application using the Java Runtime exec() method.
	Display any output to the standard BeanShell output using print().

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>exit</Name>
    <Method>
      <Name>exit</Name>
      <Sig>exit ( ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Conditionally exit the virtual machine.
	Call System.exit(0) unless bsh.system.shutdownOnExit == false.

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>extend</Name>
    <Method>
      <Name>extend</Name>
      <Sig>extend ( bsh .This parent ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Return a new object that is a child of the specified object.
	<strong>
	Note: this command will likely change along with a better inheritance 
	mechanism for bsh in a future release.</strong>
	<p>

	extend() is like the object() command, which
	creates a new bsh scripted object, except that the namespace of
	the new object is a child of the parent object. 
	<p>

	For example:
	<p>

    <pre>
    foo=object();
    bar=extend(foo);

    is equivalent to:
      
    foo() { 
        bar() {
            return this; 
        }
    }

    foo=foo();
    bar=foo.bar();

    and also:
     
    oo=object();
    ar=object();
    ar.namespace.bind( foo.namespace );
    </pre>
	<p>

	The last example above is exactly what the extend() command does.
	In each case the bar object inherits variables from foo in the usual way.
]]></Text>
      <Tags>
      <method>This extend( This object )
</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>frame</Name>
    <Method>
      <Name>frame</Name>
      <Sig>frame ( Component comp ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
    Show component in a frame, centered and packed, handling disposal with
	the close button.
	<p>

	Display the component, centered and packed, in a Frame, JFrame, or 
	JInternalFrame.  Returns the frame.  If the GUI desktop is running then a 
	JInternaFrame will be used and automatically added to the desktop.  
	Otherwise if Swing is available a top level JFrame will be created.  
	Otherwise a plain AWT Frame will be created.
]]></Text>
      <Tags>
      <method>Frame | JFrame | JInternalFrame frame( Component component )

</method>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>getClass</Name>
    <Method>
      <Name>getClass</Name>
      <Sig>Class getClass ( String name ) </Sig>
    </Method>
      <Comment>
      <Text><![CDATA[
	Get a class through the current namespace utilizing the current imports,
	extended classloader, etc.
	<p>

	This is equivalent to the standard Class.forName() method for class loading,
	however it takes advantage of the BeanShell class manager so that added 
	classpath will be taken into account.  You can also use Class.forName(), 
	however if you have modified the classpath or reloaded classes from within 
	your script the modifications will only appear if you use the getClass() 
	command.

]]></Text>
      <Tags>
      </Tags>
      </Comment>
  </File>
  <File>
    <Name>getClassPath</Name>
Script threw exception: Sourced file: /home/pat/Prj/beanshell/BeanShell/scripts/bshdoc.bsh : TargetError : at Line: 161 : in file: /home/pat/Prj/beanshell/BeanShell/scripts/bshdoc.bsh : throw new RuntimeException ( "bshdoc: Error parsing file: " + filenames [ i ] + ": " + e ) ; 

Target exception: java.lang.RuntimeException: bshdoc: Error parsing file: /home/pat/Prj/beanshell/BeanShell/src/bsh/commands/getClassPath.bsh: Parse error at line 9, column 20.  Encountered: (

